{"version":3,"file":"graphql.web.js","sources":["../src/error.ts","../src/parser.ts","../src/visitor.ts","../src/printer.ts","../src/values.ts","../src/kind.js","../src/helpers.ts"],"sourcesContent":["import type { Maybe, Extensions, Source } from './types';\nimport type { ASTNode } from './ast';\n\nexport class GraphQLError extends Error {\n  readonly locations: ReadonlyArray<any> | undefined;\n  readonly path: ReadonlyArray<string | number> | undefined;\n  readonly nodes: ReadonlyArray<any> | undefined;\n  readonly source: Source | undefined;\n  readonly positions: ReadonlyArray<number> | undefined;\n  readonly originalError: Error | undefined;\n  readonly extensions: Extensions;\n\n  constructor(\n    message: string,\n    nodes?: ReadonlyArray<ASTNode> | ASTNode | null,\n    source?: Maybe<Source>,\n    positions?: Maybe<ReadonlyArray<number>>,\n    path?: Maybe<ReadonlyArray<string | number>>,\n    originalError?: Maybe<Error>,\n    extensions?: Maybe<Extensions>\n  ) {\n    super(message);\n\n    this.name = 'GraphQLError';\n    this.message = message;\n\n    if (path) this.path = path;\n    if (nodes) this.nodes = (Array.isArray(nodes) ? nodes : [nodes]) as ASTNode[];\n    if (source) this.source = source;\n    if (positions) this.positions = positions;\n    if (originalError) this.originalError = originalError;\n\n    let _extensions = extensions;\n    if (!_extensions && originalError) {\n      const originalExtensions = (originalError as any).extensions;\n      if (originalExtensions && typeof originalExtensions === 'object') {\n        _extensions = originalExtensions;\n      }\n    }\n\n    this.extensions = _extensions || {};\n  }\n\n  toJSON(): any {\n    return { ...this, message: this.message };\n  }\n\n  toString(): string {\n    return this.message;\n  }\n\n  get [Symbol.toStringTag](): string {\n    return 'GraphQLError';\n  }\n}\n","/**\n * This is a spec-compliant implementation of a GraphQL query language parser,\n * up-to-date with the October 2021 Edition. Unlike the reference implementation\n * in graphql.js it will only parse the query language, but not the schema\n * language.\n */\nimport type { Kind, OperationTypeNode } from './kind';\nimport { GraphQLError } from './error';\nimport type { Location, Source } from './types';\nimport type * as ast from './ast';\n\nlet input: string;\nlet idx: number;\n\nfunction error(kind: string) {\n  return new GraphQLError(`Syntax Error: Unexpected token at ${idx} in ${kind}`);\n}\n\nfunction advance(pattern: RegExp) {\n  pattern.lastIndex = idx;\n  if (pattern.test(input)) {\n    const match = input.slice(idx, (idx = pattern.lastIndex));\n    return match;\n  }\n}\n\nconst leadingRe = / +(?=[^\\s])/y;\nfunction blockString(string: string) {\n  const lines = string.split('\\n');\n  let out = '';\n  let commonIndent = 0;\n  let firstNonEmptyLine = 0;\n  let lastNonEmptyLine = lines.length - 1;\n  for (let i = 0; i < lines.length; i++) {\n    leadingRe.lastIndex = 0;\n    if (leadingRe.test(lines[i])) {\n      if (i && (!commonIndent || leadingRe.lastIndex < commonIndent))\n        commonIndent = leadingRe.lastIndex;\n      firstNonEmptyLine = firstNonEmptyLine || i;\n      lastNonEmptyLine = i;\n    }\n  }\n  for (let i = firstNonEmptyLine; i <= lastNonEmptyLine; i++) {\n    if (i !== firstNonEmptyLine) out += '\\n';\n    out += lines[i].slice(commonIndent).replace(/\\\\\"\"\"/g, '\"\"\"');\n  }\n  return out;\n}\n\n// Note: This is equivalent to: /(?:[\\s,]*|#[^\\n\\r]*)*/y\nfunction ignored() {\n  for (\n    let char = input.charCodeAt(idx++) | 0;\n    char === 9 /*'\\t'*/ ||\n    char === 10 /*'\\n'*/ ||\n    char === 13 /*'\\r'*/ ||\n    char === 32 /*' '*/ ||\n    char === 35 /*'#'*/ ||\n    char === 44 /*','*/ ||\n    char === 65279 /*'\\ufeff'*/;\n    char = input.charCodeAt(idx++) | 0\n  ) {\n    if (char === 35 /*'#'*/) while ((char = input.charCodeAt(idx++)) !== 10 && char !== 13);\n  }\n  idx--;\n}\n\nfunction name(): string {\n  const start = idx;\n  for (\n    let char = input.charCodeAt(idx++) | 0;\n    (char >= 48 /*'0'*/ && char <= 57) /*'9'*/ ||\n    (char >= 65 /*'A'*/ && char <= 90) /*'Z'*/ ||\n    char === 95 /*'_'*/ ||\n    (char >= 97 /*'a'*/ && char <= 122) /*'z'*/;\n    char = input.charCodeAt(idx++) | 0\n  );\n  if (start === idx - 1) throw error('Name');\n  const value = input.slice(start, --idx);\n  ignored();\n  return value;\n}\n\nfunction nameNode(): ast.NameNode {\n  return {\n    kind: 'Name' as Kind.NAME,\n    value: name(),\n  };\n}\n\nconst restBlockStringRe = /(?:\"\"\"|(?:[\\s\\S]*?[^\\\\])\"\"\")/y;\nconst floatPartRe = /(?:(?:\\.\\d+)?[eE][+-]?\\d+|\\.\\d+)/y;\n\nfunction value(constant: true): ast.ConstValueNode;\nfunction value(constant: boolean): ast.ValueNode;\n\nfunction value(constant: boolean): ast.ValueNode {\n  let match: string | undefined;\n  switch (input.charCodeAt(idx)) {\n    case 91: // '['\n      idx++;\n      ignored();\n      const values: ast.ValueNode[] = [];\n      while (input.charCodeAt(idx) !== 93 /*']'*/) values.push(value(constant));\n      idx++;\n      ignored();\n      return {\n        kind: 'ListValue' as Kind.LIST,\n        values,\n      };\n\n    case 123: // '{'\n      idx++;\n      ignored();\n      const fields: ast.ObjectFieldNode[] = [];\n      while (input.charCodeAt(idx) !== 125 /*'}'*/) {\n        const name = nameNode();\n        if (input.charCodeAt(idx++) !== 58 /*':'*/) throw error('ObjectField');\n        ignored();\n        fields.push({\n          kind: 'ObjectField' as Kind.OBJECT_FIELD,\n          name,\n          value: value(constant),\n        });\n      }\n      idx++;\n      ignored();\n      return {\n        kind: 'ObjectValue' as Kind.OBJECT,\n        fields,\n      };\n\n    case 36: // '$'\n      if (constant) throw error('Variable');\n      idx++;\n      return {\n        kind: 'Variable' as Kind.VARIABLE,\n        name: nameNode(),\n      };\n\n    case 34: // '\"'\n      if (input.charCodeAt(idx + 1) === 34 && input.charCodeAt(idx + 2) === 34) {\n        idx += 3;\n        if ((match = advance(restBlockStringRe)) == null) throw error('StringValue');\n        ignored();\n        return {\n          kind: 'StringValue' as Kind.STRING,\n          value: blockString(match.slice(0, -3)),\n          block: true,\n        };\n      } else {\n        const start = idx;\n        idx++;\n        let char: number;\n        let isComplex = false;\n        for (\n          char = input.charCodeAt(idx++) | 0;\n          (char === 92 /*'\\\\'*/ && (idx++, (isComplex = true))) ||\n          (char !== 10 /*'\\n'*/ && char !== 13 /*'\\r'*/ && char !== 34 /*'\"'*/ && char);\n          char = input.charCodeAt(idx++) | 0\n        );\n        if (char !== 34) throw error('StringValue');\n        match = input.slice(start, idx);\n        ignored();\n        return {\n          kind: 'StringValue' as Kind.STRING,\n          value: isComplex ? (JSON.parse(match) as string) : match.slice(1, -1),\n          block: false,\n        };\n      }\n\n    case 45: // '-'\n    case 48: // '0'\n    case 49: // '1'\n    case 50: // '2'\n    case 51: // '3'\n    case 52: // '4'\n    case 53: // '5'\n    case 54: // '6'\n    case 55: // '7'\n    case 56: // '8'\n    case 57: // '9'\n      const start = idx++;\n      let char: number;\n      while ((char = input.charCodeAt(idx++) | 0) >= 48 /*'0'*/ && char <= 57 /*'9'*/);\n      const intPart = input.slice(start, --idx);\n      if (\n        (char = input.charCodeAt(idx)) === 46 /*'.'*/ ||\n        char === 69 /*'E'*/ ||\n        char === 101 /*'e'*/\n      ) {\n        if ((match = advance(floatPartRe)) == null) throw error('FloatValue');\n        ignored();\n        return {\n          kind: 'FloatValue' as Kind.FLOAT,\n          value: intPart + match,\n        };\n      } else {\n        ignored();\n        return {\n          kind: 'IntValue' as Kind.INT,\n          value: intPart,\n        };\n      }\n\n    case 110: // 'n'\n      if (\n        input.charCodeAt(idx + 1) === 117 &&\n        input.charCodeAt(idx + 2) === 108 &&\n        input.charCodeAt(idx + 3) === 108\n      ) {\n        idx += 4;\n        ignored();\n        return { kind: 'NullValue' as Kind.NULL };\n      } else break;\n\n    case 116: // 't'\n      if (\n        input.charCodeAt(idx + 1) === 114 &&\n        input.charCodeAt(idx + 2) === 117 &&\n        input.charCodeAt(idx + 3) === 101\n      ) {\n        idx += 4;\n        ignored();\n        return { kind: 'BooleanValue' as Kind.BOOLEAN, value: true };\n      } else break;\n\n    case 102: // 'f'\n      if (\n        input.charCodeAt(idx + 1) === 97 &&\n        input.charCodeAt(idx + 2) === 108 &&\n        input.charCodeAt(idx + 3) === 115 &&\n        input.charCodeAt(idx + 4) === 101\n      ) {\n        idx += 5;\n        ignored();\n        return { kind: 'BooleanValue' as Kind.BOOLEAN, value: false };\n      } else break;\n  }\n\n  return {\n    kind: 'EnumValue' as Kind.ENUM,\n    value: name(),\n  };\n}\n\nfunction arguments_(constant: boolean): ast.ArgumentNode[] | undefined {\n  if (input.charCodeAt(idx) === 40 /*'('*/) {\n    const args: ast.ArgumentNode[] = [];\n    idx++;\n    ignored();\n    do {\n      const name = nameNode();\n      if (input.charCodeAt(idx++) !== 58 /*':'*/) throw error('Argument');\n      ignored();\n      args.push({\n        kind: 'Argument' as Kind.ARGUMENT,\n        name,\n        value: value(constant),\n      });\n    } while (input.charCodeAt(idx) !== 41 /*')'*/);\n    idx++;\n    ignored();\n    return args;\n  }\n}\n\nfunction directives(constant: true): ast.ConstDirectiveNode[] | undefined;\nfunction directives(constant: boolean): ast.DirectiveNode[] | undefined;\n\nfunction directives(constant: boolean): ast.DirectiveNode[] | undefined {\n  if (input.charCodeAt(idx) === 64 /*'@'*/) {\n    const directives: ast.DirectiveNode[] = [];\n    do {\n      idx++;\n      directives.push({\n        kind: 'Directive' as Kind.DIRECTIVE,\n        name: nameNode(),\n        arguments: arguments_(constant),\n      });\n    } while (input.charCodeAt(idx) === 64 /*'@'*/);\n    return directives;\n  }\n}\n\nfunction type(): ast.TypeNode {\n  let lists = 0;\n  while (input.charCodeAt(idx) === 91 /*'['*/) {\n    lists++;\n    idx++;\n    ignored();\n  }\n  let type: ast.TypeNode = {\n    kind: 'NamedType' as Kind.NAMED_TYPE,\n    name: nameNode(),\n  };\n  do {\n    if (input.charCodeAt(idx) === 33 /*'!'*/) {\n      idx++;\n      ignored();\n      type = {\n        kind: 'NonNullType' as Kind.NON_NULL_TYPE,\n        type: type as ast.NamedTypeNode | ast.ListTypeNode,\n      } satisfies ast.NonNullTypeNode;\n    }\n    if (lists) {\n      if (input.charCodeAt(idx++) !== 93 /*']'*/) throw error('NamedType');\n      ignored();\n      type = {\n        kind: 'ListType' as Kind.LIST_TYPE,\n        type: type as ast.NamedTypeNode | ast.ListTypeNode,\n      } satisfies ast.ListTypeNode;\n    }\n  } while (lists--);\n  return type;\n}\n\nfunction selectionSetStart(): ast.SelectionSetNode {\n  if (input.charCodeAt(idx++) !== 123 /*'{'*/) throw error('SelectionSet');\n  ignored();\n  return selectionSet();\n}\n\nfunction selectionSet(): ast.SelectionSetNode {\n  const selections: ast.SelectionNode[] = [];\n  do {\n    if (input.charCodeAt(idx) === 46 /*'.'*/) {\n      if (input.charCodeAt(++idx) !== 46 /*'.'*/ || input.charCodeAt(++idx) !== 46 /*'.'*/)\n        throw error('SelectionSet');\n      idx++;\n      ignored();\n      switch (input.charCodeAt(idx)) {\n        case 64 /*'@'*/:\n          selections.push({\n            kind: 'InlineFragment' as Kind.INLINE_FRAGMENT,\n            typeCondition: undefined,\n            directives: directives(false),\n            selectionSet: selectionSetStart(),\n          });\n          break;\n\n        case 111 /*'o'*/:\n          if (input.charCodeAt(idx + 1) === 110 /*'n'*/) {\n            idx += 2;\n            ignored();\n            selections.push({\n              kind: 'InlineFragment' as Kind.INLINE_FRAGMENT,\n              typeCondition: {\n                kind: 'NamedType' as Kind.NAMED_TYPE,\n                name: nameNode(),\n              },\n              directives: directives(false),\n              selectionSet: selectionSetStart(),\n            });\n          } else {\n            selections.push({\n              kind: 'FragmentSpread' as Kind.FRAGMENT_SPREAD,\n              name: nameNode(),\n              directives: directives(false),\n            });\n          }\n          break;\n\n        case 123 /*'{'*/:\n          idx++;\n          ignored();\n          selections.push({\n            kind: 'InlineFragment' as Kind.INLINE_FRAGMENT,\n            typeCondition: undefined,\n            directives: undefined,\n            selectionSet: selectionSet(),\n          });\n          break;\n\n        default:\n          selections.push({\n            kind: 'FragmentSpread' as Kind.FRAGMENT_SPREAD,\n            name: nameNode(),\n            directives: directives(false),\n          });\n      }\n    } else {\n      let name = nameNode();\n      let alias: ast.NameNode | undefined;\n      if (input.charCodeAt(idx) === 58 /*':'*/) {\n        idx++;\n        ignored();\n        alias = name;\n        name = nameNode();\n      }\n      const _arguments = arguments_(false);\n      const _directives = directives(false);\n      let _selectionSet: ast.SelectionSetNode | undefined;\n      if (input.charCodeAt(idx) === 123 /*'{'*/) {\n        idx++;\n        ignored();\n        _selectionSet = selectionSet();\n      }\n      selections.push({\n        kind: 'Field' as Kind.FIELD,\n        alias,\n        name,\n        arguments: _arguments,\n        directives: _directives,\n        selectionSet: _selectionSet,\n      });\n    }\n  } while (input.charCodeAt(idx) !== 125 /*'}'*/);\n  idx++;\n  ignored();\n  return {\n    kind: 'SelectionSet' as Kind.SELECTION_SET,\n    selections,\n  };\n}\n\nfunction variableDefinitions(): ast.VariableDefinitionNode[] | undefined {\n  ignored();\n  if (input.charCodeAt(idx) === 40 /*'('*/) {\n    const vars: ast.VariableDefinitionNode[] = [];\n    idx++;\n    ignored();\n    do {\n      if (input.charCodeAt(idx++) !== 36 /*'$'*/) throw error('Variable');\n      const name = nameNode();\n      if (input.charCodeAt(idx++) !== 58 /*':'*/) throw error('VariableDefinition');\n      ignored();\n      const _type = type();\n      let _defaultValue: ast.ConstValueNode | undefined;\n      if (input.charCodeAt(idx) === 61 /*'='*/) {\n        idx++;\n        ignored();\n        _defaultValue = value(true);\n      }\n      ignored();\n      vars.push({\n        kind: 'VariableDefinition' as Kind.VARIABLE_DEFINITION,\n        variable: {\n          kind: 'Variable' as Kind.VARIABLE,\n          name,\n        },\n        type: _type,\n        defaultValue: _defaultValue,\n        directives: directives(true),\n      });\n    } while (input.charCodeAt(idx) !== 41 /*')'*/);\n    idx++;\n    ignored();\n    return vars;\n  }\n}\n\nfunction fragmentDefinition(): ast.FragmentDefinitionNode {\n  const name = nameNode();\n  if (input.charCodeAt(idx++) !== 111 /*'o'*/ || input.charCodeAt(idx++) !== 110 /*'n'*/)\n    throw error('FragmentDefinition');\n  ignored();\n  return {\n    kind: 'FragmentDefinition' as Kind.FRAGMENT_DEFINITION,\n    name,\n    typeCondition: {\n      kind: 'NamedType' as Kind.NAMED_TYPE,\n      name: nameNode(),\n    },\n    directives: directives(false),\n    selectionSet: selectionSetStart(),\n  };\n}\n\nfunction document(input: string, noLoc: boolean): ast.DocumentNode {\n  ignored();\n  const definitions: ast.ExecutableDefinitionNode[] = [];\n  do {\n    if (input.charCodeAt(idx) === 123 /*'{'*/) {\n      definitions.push({\n        kind: 'OperationDefinition' as Kind.OPERATION_DEFINITION,\n        operation: 'query' as OperationTypeNode.QUERY,\n        name: undefined,\n        variableDefinitions: undefined,\n        directives: undefined,\n        selectionSet: selectionSetStart(),\n      });\n    } else {\n      const definition = name();\n      switch (definition) {\n        case 'fragment':\n          definitions.push(fragmentDefinition());\n          break;\n        case 'query':\n        case 'mutation':\n        case 'subscription':\n          let char: number;\n          let name: ast.NameNode | undefined;\n          if (\n            (char = input.charCodeAt(idx)) !== 40 /*'('*/ &&\n            char !== 64 /*'@'*/ &&\n            char !== 123 /*'{'*/\n          ) {\n            name = nameNode();\n          }\n          definitions.push({\n            kind: 'OperationDefinition' as Kind.OPERATION_DEFINITION,\n            operation: definition as OperationTypeNode,\n            name,\n            variableDefinitions: variableDefinitions(),\n            directives: directives(false),\n            selectionSet: selectionSetStart(),\n          });\n          break;\n        default:\n          throw error('Document');\n      }\n    }\n  } while (idx < input.length);\n\n  if (!noLoc) {\n    let loc: Location | undefined;\n    return {\n      kind: 'Document' as Kind.DOCUMENT,\n      definitions,\n      /* v8 ignore start */\n      set loc(_loc: Location) {\n        loc = _loc;\n      },\n      /* v8 ignore stop */\n      // @ts-ignore\n      get loc() {\n        if (!loc) {\n          loc = {\n            start: 0,\n            end: input.length,\n            startToken: undefined,\n            endToken: undefined,\n            source: {\n              body: input,\n              name: 'graphql.web',\n              locationOffset: { line: 1, column: 1 },\n            },\n          };\n        }\n        return loc;\n      },\n    };\n  }\n\n  return {\n    kind: 'Document' as Kind.DOCUMENT,\n    definitions,\n  };\n}\n\ntype ParseOptions = {\n  [option: string]: any;\n};\n\nexport function parse(\n  string: string | Source,\n  options?: ParseOptions | undefined\n): ast.DocumentNode {\n  input = string.body ? string.body : string;\n  idx = 0;\n  return document(input, options && options.noLocation);\n}\n\nexport function parseValue(\n  string: string | Source,\n  _options?: ParseOptions | undefined\n): ast.ValueNode {\n  input = string.body ? string.body : string;\n  idx = 0;\n  ignored();\n  return value(false);\n}\n\nexport function parseType(\n  string: string | Source,\n  _options?: ParseOptions | undefined\n): ast.TypeNode {\n  input = string.body ? string.body : string;\n  idx = 0;\n  return type();\n}\n","import type { ASTNode } from './ast';\n\nexport const BREAK = {};\n\nexport function visit<N extends ASTNode>(root: N, visitor: ASTVisitor): N;\nexport function visit<R>(root: ASTNode, visitor: ASTReducer<R>): R;\n\nexport function visit(node: ASTNode, visitor: ASTVisitor | ASTReducer<any>) {\n  const ancestors: Array<ASTNode | ReadonlyArray<ASTNode>> = [];\n  const path: Array<string | number> = [];\n\n  function traverse(\n    node: ASTNode,\n    key?: string | number | undefined,\n    parent?: ASTNode | ReadonlyArray<ASTNode> | undefined\n  ) {\n    let hasEdited = false;\n\n    const enter =\n      (visitor[node.kind] && visitor[node.kind].enter) ||\n      visitor[node.kind] ||\n      (visitor as EnterLeaveVisitor<ASTNode>).enter;\n    const resultEnter = enter && enter.call(visitor, node, key, parent, path, ancestors);\n    if (resultEnter === false) {\n      return node;\n    } else if (resultEnter === null) {\n      return null;\n    } else if (resultEnter === BREAK) {\n      throw BREAK;\n    } else if (resultEnter && typeof resultEnter.kind === 'string') {\n      hasEdited = resultEnter !== node;\n      node = resultEnter;\n    }\n\n    if (parent) ancestors.push(parent);\n\n    let result: any;\n    const copy = { ...node };\n    for (const nodeKey in node) {\n      path.push(nodeKey);\n      let value = node[nodeKey];\n      if (Array.isArray(value)) {\n        const newValue: any[] = [];\n        for (let index = 0; index < value.length; index++) {\n          if (value[index] != null && typeof value[index].kind === 'string') {\n            ancestors.push(node);\n            path.push(index);\n            result = traverse(value[index], index, value);\n            path.pop();\n            ancestors.pop();\n            if (result == null) {\n              hasEdited = true;\n            } else {\n              hasEdited = hasEdited || result !== value[index];\n              newValue.push(result);\n            }\n          }\n        }\n        value = newValue;\n      } else if (value != null && typeof value.kind === 'string') {\n        result = traverse(value, nodeKey, node);\n        if (result !== undefined) {\n          hasEdited = hasEdited || value !== result;\n          value = result;\n        }\n      }\n\n      path.pop();\n      if (hasEdited) copy[nodeKey] = value;\n    }\n\n    if (parent) ancestors.pop();\n    const leave =\n      (visitor[node.kind] && visitor[node.kind].leave) ||\n      (visitor as EnterLeaveVisitor<ASTNode>).leave;\n    const resultLeave = leave && leave.call(visitor, node, key, parent, path, ancestors);\n    if (resultLeave === BREAK) {\n      throw BREAK;\n    } else if (resultLeave !== undefined) {\n      return resultLeave;\n    } else if (resultEnter !== undefined) {\n      return hasEdited ? copy : resultEnter;\n    } else {\n      return hasEdited ? copy : node;\n    }\n  }\n\n  try {\n    const result = traverse(node);\n    return result !== undefined && result !== false ? result : node;\n  } catch (error) {\n    if (error !== BREAK) throw error;\n    return node;\n  }\n}\n\nexport type ASTVisitor = EnterLeaveVisitor<ASTNode> | KindVisitor;\n\ntype KindVisitor = {\n  readonly [NodeT in ASTNode as NodeT['kind']]?: ASTVisitFn<NodeT> | EnterLeaveVisitor<NodeT>;\n};\n\ninterface EnterLeaveVisitor<TVisitedNode extends ASTNode> {\n  readonly enter?: ASTVisitFn<TVisitedNode> | undefined;\n  readonly leave?: ASTVisitFn<TVisitedNode> | undefined;\n}\n\nexport type ASTVisitFn<Node extends ASTNode> = (\n  node: Node,\n  key: string | number | undefined,\n  parent: ASTNode | ReadonlyArray<ASTNode> | undefined,\n  path: ReadonlyArray<string | number>,\n  ancestors: ReadonlyArray<ASTNode | ReadonlyArray<ASTNode>>\n) => any;\n\nexport type ASTReducer<R> = {\n  readonly [NodeT in ASTNode as NodeT['kind']]?: {\n    readonly enter?: ASTVisitFn<NodeT>;\n    readonly leave: ASTReducerFn<NodeT, R>;\n  };\n};\n\ntype ASTReducerFn<TReducedNode extends ASTNode, R> = (\n  node: { [K in keyof TReducedNode]: ReducedField<TReducedNode[K], R> },\n  key: string | number | undefined,\n  parent: ASTNode | ReadonlyArray<ASTNode> | undefined,\n  path: ReadonlyArray<string | number>,\n  ancestors: ReadonlyArray<ASTNode | ReadonlyArray<ASTNode>>\n) => R;\n\ntype ReducedField<T, R> = T extends null | undefined\n  ? T\n  : T extends ReadonlyArray<any>\n    ? ReadonlyArray<R>\n    : R;\n","import type {\n  ASTNode,\n  NameNode,\n  DocumentNode,\n  VariableNode,\n  SelectionSetNode,\n  FieldNode,\n  ArgumentNode,\n  FragmentSpreadNode,\n  InlineFragmentNode,\n  VariableDefinitionNode,\n  OperationDefinitionNode,\n  FragmentDefinitionNode,\n  IntValueNode,\n  FloatValueNode,\n  StringValueNode,\n  BooleanValueNode,\n  NullValueNode,\n  EnumValueNode,\n  ListValueNode,\n  ObjectValueNode,\n  ObjectFieldNode,\n  DirectiveNode,\n  NamedTypeNode,\n  ListTypeNode,\n  NonNullTypeNode,\n} from './ast';\n\nfunction mapJoin<T>(value: readonly T[], joiner: string, mapper: (value: T) => string): string {\n  let out = '';\n  for (let index = 0; index < value.length; index++) {\n    if (index) out += joiner;\n    out += mapper(value[index]);\n  }\n  return out;\n}\n\nfunction printString(string: string): string {\n  return JSON.stringify(string);\n}\n\nfunction printBlockString(string: string): string {\n  return '\"\"\"\\n' + string.replace(/\"\"\"/g, '\\\\\"\"\"') + '\\n\"\"\"';\n}\n\nconst MAX_LINE_LENGTH = 80;\n\nlet LF = '\\n';\n\nconst nodes = {\n  OperationDefinition(node: OperationDefinitionNode): string {\n    let out: string = node.operation;\n    if (node.name) out += ' ' + node.name.value;\n    if (node.variableDefinitions && node.variableDefinitions.length) {\n      if (!node.name) out += ' ';\n      out += '(' + mapJoin(node.variableDefinitions, ', ', nodes.VariableDefinition) + ')';\n    }\n    if (node.directives && node.directives.length)\n      out += ' ' + mapJoin(node.directives, ' ', nodes.Directive);\n    return out !== 'query'\n      ? out + ' ' + nodes.SelectionSet(node.selectionSet)\n      : nodes.SelectionSet(node.selectionSet);\n  },\n  VariableDefinition(node: VariableDefinitionNode): string {\n    let out = nodes.Variable!(node.variable) + ': ' + _print(node.type);\n    if (node.defaultValue) out += ' = ' + _print(node.defaultValue);\n    if (node.directives && node.directives.length)\n      out += ' ' + mapJoin(node.directives, ' ', nodes.Directive);\n    return out;\n  },\n  Field(node: FieldNode): string {\n    let out = node.alias ? node.alias.value + ': ' + node.name.value : node.name.value;\n    if (node.arguments && node.arguments.length) {\n      const args = mapJoin(node.arguments, ', ', nodes.Argument);\n      if (out.length + args.length + 2 > MAX_LINE_LENGTH) {\n        out +=\n          '(' +\n          (LF += '  ') +\n          mapJoin(node.arguments, LF, nodes.Argument) +\n          (LF = LF.slice(0, -2)) +\n          ')';\n      } else {\n        out += '(' + args + ')';\n      }\n    }\n    if (node.directives && node.directives.length)\n      out += ' ' + mapJoin(node.directives, ' ', nodes.Directive);\n    if (node.selectionSet && node.selectionSet.selections.length) {\n      out += ' ' + nodes.SelectionSet(node.selectionSet);\n    }\n    return out;\n  },\n  StringValue(node: StringValueNode): string {\n    if (node.block) {\n      return printBlockString(node.value).replace(/\\n/g, LF);\n    } else {\n      return printString(node.value);\n    }\n  },\n  BooleanValue(node: BooleanValueNode): string {\n    return '' + node.value;\n  },\n  NullValue(_node: NullValueNode): string {\n    return 'null';\n  },\n  IntValue(node: IntValueNode): string {\n    return node.value;\n  },\n  FloatValue(node: FloatValueNode): string {\n    return node.value;\n  },\n  EnumValue(node: EnumValueNode): string {\n    return node.value;\n  },\n  Name(node: NameNode): string {\n    return node.value;\n  },\n  Variable(node: VariableNode): string {\n    return '$' + node.name.value;\n  },\n  ListValue(node: ListValueNode): string {\n    return '[' + mapJoin(node.values, ', ', _print) + ']';\n  },\n  ObjectValue(node: ObjectValueNode): string {\n    return '{' + mapJoin(node.fields, ', ', nodes.ObjectField) + '}';\n  },\n  ObjectField(node: ObjectFieldNode): string {\n    return node.name.value + ': ' + _print(node.value);\n  },\n  Document(node: DocumentNode): string {\n    if (!node.definitions || !node.definitions.length) return '';\n    return mapJoin(node.definitions, '\\n\\n', _print);\n  },\n  SelectionSet(node: SelectionSetNode): string {\n    return '{' + (LF += '  ') + mapJoin(node.selections, LF, _print) + (LF = LF.slice(0, -2)) + '}';\n  },\n  Argument(node: ArgumentNode): string {\n    return node.name.value + ': ' + _print(node.value);\n  },\n  FragmentSpread(node: FragmentSpreadNode): string {\n    let out = '...' + node.name.value;\n    if (node.directives && node.directives.length)\n      out += ' ' + mapJoin(node.directives, ' ', nodes.Directive);\n    return out;\n  },\n  InlineFragment(node: InlineFragmentNode): string {\n    let out = '...';\n    if (node.typeCondition) out += ' on ' + node.typeCondition.name.value;\n    if (node.directives && node.directives.length)\n      out += ' ' + mapJoin(node.directives, ' ', nodes.Directive);\n    out += ' ' + nodes.SelectionSet(node.selectionSet);\n    return out;\n  },\n  FragmentDefinition(node: FragmentDefinitionNode): string {\n    let out = 'fragment ' + node.name.value;\n    out += ' on ' + node.typeCondition.name.value;\n    if (node.directives && node.directives.length)\n      out += ' ' + mapJoin(node.directives, ' ', nodes.Directive);\n    return out + ' ' + nodes.SelectionSet(node.selectionSet);\n  },\n  Directive(node: DirectiveNode): string {\n    let out = '@' + node.name.value;\n    if (node.arguments && node.arguments.length)\n      out += '(' + mapJoin(node.arguments, ', ', nodes.Argument) + ')';\n    return out;\n  },\n  NamedType(node: NamedTypeNode): string {\n    return node.name.value;\n  },\n  ListType(node: ListTypeNode): string {\n    return '[' + _print(node.type) + ']';\n  },\n  NonNullType(node: NonNullTypeNode): string {\n    return _print(node.type) + '!';\n  },\n} as const;\n\nconst _print = (node: ASTNode): string => nodes[node.kind](node);\n\nfunction print(node: ASTNode): string {\n  LF = '\\n';\n  return nodes[node.kind] ? nodes[node.kind](node) : '';\n}\n\nexport { print, printString, printBlockString };\n","import type { TypeNode, ValueNode } from './ast';\nimport type { Maybe } from './types';\n\nexport function valueFromASTUntyped(\n  node: ValueNode,\n  variables?: Maybe<Record<string, any>>\n): unknown {\n  switch (node.kind) {\n    case 'NullValue':\n      return null;\n    case 'IntValue':\n      return parseInt(node.value, 10);\n    case 'FloatValue':\n      return parseFloat(node.value);\n    case 'StringValue':\n    case 'EnumValue':\n    case 'BooleanValue':\n      return node.value;\n    case 'ListValue': {\n      const values: unknown[] = [];\n      for (let i = 0, l = node.values.length; i < l; i++)\n        values.push(valueFromASTUntyped(node.values[i], variables));\n      return values;\n    }\n    case 'ObjectValue': {\n      const obj = Object.create(null);\n      for (let i = 0, l = node.fields.length; i < l; i++) {\n        const field = node.fields[i];\n        obj[field.name.value] = valueFromASTUntyped(field.value, variables);\n      }\n      return obj;\n    }\n    case 'Variable':\n      return variables && variables[node.name.value];\n  }\n}\n\nexport function valueFromTypeNode(\n  node: ValueNode,\n  type: TypeNode,\n  variables?: Maybe<Record<string, any>>\n): unknown {\n  if (node.kind === 'Variable') {\n    const variableName = node.name.value;\n    return variables ? valueFromTypeNode(variables[variableName], type, variables) : undefined;\n  } else if (type.kind === 'NonNullType') {\n    return node.kind !== 'NullValue' ? valueFromTypeNode(node, type, variables) : undefined;\n  } else if (node.kind === 'NullValue') {\n    return null;\n  } else if (type.kind === 'ListType') {\n    if (node.kind === 'ListValue') {\n      const values: unknown[] = [];\n      for (let i = 0, l = node.values.length; i < l; i++) {\n        const value = node.values[i];\n        const coerced = valueFromTypeNode(value, type.type, variables);\n        if (coerced === undefined) {\n          return undefined;\n        } else {\n          values.push(coerced);\n        }\n      }\n      return values;\n    }\n  } else if (type.kind === 'NamedType') {\n    switch (type.name.value) {\n      case 'Int':\n      case 'Float':\n      case 'String':\n      case 'Bool':\n        return type.name.value + 'Value' === node.kind\n          ? valueFromASTUntyped(node, variables)\n          : undefined;\n      default:\n        return valueFromASTUntyped(node, variables);\n    }\n  }\n}\n","export const Kind = {\n  NAME: 'Name',\n  DOCUMENT: 'Document',\n  OPERATION_DEFINITION: 'OperationDefinition',\n  VARIABLE_DEFINITION: 'VariableDefinition',\n  SELECTION_SET: 'SelectionSet',\n  FIELD: 'Field',\n  ARGUMENT: 'Argument',\n  FRAGMENT_SPREAD: 'FragmentSpread',\n  INLINE_FRAGMENT: 'InlineFragment',\n  FRAGMENT_DEFINITION: 'FragmentDefinition',\n  VARIABLE: 'Variable',\n  INT: 'IntValue',\n  FLOAT: 'FloatValue',\n  STRING: 'StringValue',\n  BOOLEAN: 'BooleanValue',\n  NULL: 'NullValue',\n  ENUM: 'EnumValue',\n  LIST: 'ListValue',\n  OBJECT: 'ObjectValue',\n  OBJECT_FIELD: 'ObjectField',\n  DIRECTIVE: 'Directive',\n  NAMED_TYPE: 'NamedType',\n  LIST_TYPE: 'ListType',\n  NON_NULL_TYPE: 'NonNullType',\n\n  /*\n  SCHEMA_DEFINITION: 'SchemaDefinition',\n  OPERATION_TYPE_DEFINITION: 'OperationTypeDefinition',\n  SCALAR_TYPE_DEFINITION: 'ScalarTypeDefinition',\n  OBJECT_TYPE_DEFINITION: 'ObjectTypeDefinition',\n  FIELD_DEFINITION: 'FieldDefinition',\n  INPUT_VALUE_DEFINITION: 'InputValueDefinition',\n  INTERFACE_TYPE_DEFINITION: 'InterfaceTypeDefinition',\n  UNION_TYPE_DEFINITION: 'UnionTypeDefinition',\n  ENUM_TYPE_DEFINITION: 'EnumTypeDefinition',\n  ENUM_VALUE_DEFINITION: 'EnumValueDefinition',\n  INPUT_OBJECT_TYPE_DEFINITION: 'InputObjectTypeDefinition',\n  DIRECTIVE_DEFINITION: 'DirectiveDefinition',\n  SCHEMA_EXTENSION: 'SchemaExtension',\n  SCALAR_TYPE_EXTENSION: 'ScalarTypeExtension',\n  OBJECT_TYPE_EXTENSION: 'ObjectTypeExtension',\n  INTERFACE_TYPE_EXTENSION: 'InterfaceTypeExtension',\n  UNION_TYPE_EXTENSION: 'UnionTypeExtension',\n  ENUM_TYPE_EXTENSION: 'EnumTypeExtension',\n  INPUT_OBJECT_TYPE_EXTENSION: 'InputObjectTypeExtension',\n  */\n};\n\nexport const OperationTypeNode = {\n  QUERY: 'query',\n  MUTATION: 'mutation',\n  SUBSCRIPTION: 'subscription',\n};\n","import type { Location, Source as _Source } from './types';\nimport type { ASTNode, SelectionNode } from './ast';\n\nexport function isSelectionNode(node: ASTNode): node is SelectionNode {\n  return node.kind === 'Field' || node.kind === 'FragmentSpread' || node.kind === 'InlineFragment';\n}\n\nexport function Source(body: string, name?: string, locationOffset?: Location): _Source {\n  return {\n    body,\n    name,\n    locationOffset: locationOffset || { line: 1, column: 1 },\n  };\n}\n"],"names":["GraphQLError","Error","constructor","message","nodes","source","positions","path","originalError","extensions","super","this","name","Array","isArray","_extensions","originalExtensions","toJSON","toString","Symbol","toStringTag","input","idx","error","kind","advance","pattern","lastIndex","test","slice","leadingRe","blockString","string","lines","split","out","commonIndent","firstNonEmptyLine","lastNonEmptyLine","length","i","replace","ignored","char","charCodeAt","start","value","nameNode","restBlockStringRe","floatPartRe","constant","match","values","push","fields","block","isComplex","JSON","parse","intPart","arguments_","args","directives","arguments","type","lists","selectionSetStart","selectionSet","selections","typeCondition","undefined","alias","_arguments","_directives","_selectionSet","variableDefinitions","vars","_type","_defaultValue","variable","defaultValue","fragmentDefinition","BREAK","mapJoin","joiner","mapper","index","printString","stringify","printBlockString","LF","OperationDefinition","node","operation","VariableDefinition","Directive","SelectionSet","Variable","_print","Field","Argument","StringValue","BooleanValue","NullValue","_node","IntValue","FloatValue","EnumValue","Name","ListValue","ObjectValue","ObjectField","Document","definitions","FragmentSpread","InlineFragment","FragmentDefinition","NamedType","ListType","NonNullType","valueFromASTUntyped","variables","parseInt","parseFloat","l","obj","Object","create","field","NAME","DOCUMENT","OPERATION_DEFINITION","VARIABLE_DEFINITION","SELECTION_SET","FIELD","ARGUMENT","FRAGMENT_SPREAD","INLINE_FRAGMENT","FRAGMENT_DEFINITION","VARIABLE","INT","FLOAT","STRING","BOOLEAN","NULL","ENUM","LIST","OBJECT","OBJECT_FIELD","DIRECTIVE","NAMED_TYPE","LIST_TYPE","NON_NULL_TYPE","QUERY","MUTATION","SUBSCRIPTION","Source","body","locationOffset","line","column","isSelectionNode","options","document","noLoc","definition","loc","_loc","end","startToken","endToken","noLocation","parseType","_options","parseValue","print","valueFromTypeNode","coerced","visit","visitor","ancestors","result","traverse","key","parent","hasEdited","enter","resultEnter","call","copy","nodeKey","newValue","pop","leave","resultLeave"],"mappings":"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"}