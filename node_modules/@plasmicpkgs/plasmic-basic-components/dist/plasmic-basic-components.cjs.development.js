'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var registerComponent = _interopDefault(require('@plasmicapp/host/registerComponent'));
var React = require('react');
var React__default = _interopDefault(React);
var host = require('@plasmicapp/host');
var plasmicQuery = require('@plasmicapp/query');

function ConditionGuardOnNotSatisfied(_ref) {
  var onNotSatisfied = _ref.onNotSatisfied;
  var ref = React__default.useRef(false);
  React__default.useEffect(function () {
    if (!ref.current) {
      ref.current = true;
      onNotSatisfied == null || onNotSatisfied();
    }
  }, [onNotSatisfied]);
  return null;
}
function isCurrentLocationInSkipPaths(skipPaths) {
  var _globalThis$__PLASMIC;
  var pathname = window.location.pathname;
  // Ignore search params
  var currentPath = window.location.origin + pathname;
  var plasmicPathname = globalThis == null || (_globalThis$__PLASMIC = globalThis["__PLASMIC_STUDIO_PATH"]) == null ? void 0 : _globalThis$__PLASMIC.call(globalThis);
  return skipPaths == null ? void 0 : skipPaths.some(function (_ref2) {
    var path = _ref2.path;
    return path === pathname || path === currentPath || path === plasmicPathname;
  });
}
function ConditionGuard(_ref3) {
  var condition = _ref3.condition,
    onNotSatisfied = _ref3.onNotSatisfied,
    children = _ref3.children,
    skipPaths = _ref3.skipPaths;
  if (!condition && !isCurrentLocationInSkipPaths(skipPaths)) {
    return React__default.createElement(ConditionGuardOnNotSatisfied, {
      onNotSatisfied: onNotSatisfied
    });
  }
  return React__default.createElement(React__default.Fragment, null, children);
}
var conditionGuardMeta = {
  name: "hostless-condition-guard",
  displayName: "Condition Guard",
  description: "Ensure some condition, or else run an interaction. Examples: ensure all users have a database row, or require new users to setup a profile.",
  importName: "ConditionGuard",
  importPath: "@plasmicpkgs/plasmic-basic-components",
  props: {
    children: "slot",
    condition: {
      type: "boolean",
      displayName: "Condition",
      description: "The condition to guard against",
      helpText: "Condition to check. Render contents only if true. Run interaction if false.",
      defaultValue: true
    },
    onNotSatisfied: {
      type: "eventHandler",
      displayName: "On condition false",
      description: "The action to run when the condition is not satisfied",
      argTypes: []
    },
    skipPaths: {
      type: "array",
      displayName: "Skip Paths",
      description: "Paths that the action should not run",
      itemType: {
        type: "object",
        fields: {
          path: "href"
        },
        nameFunc: function nameFunc(item) {
          return item == null ? void 0 : item.path;
        }
      }
    }
  }
};
function registerConditionGuard(loader, customConditionGuardMeta) {
  if (loader) {
    loader.registerComponent(ConditionGuard, customConditionGuardMeta != null ? customConditionGuardMeta : conditionGuardMeta);
  } else {
    registerComponent(ConditionGuard, customConditionGuardMeta != null ? customConditionGuardMeta : conditionGuardMeta);
  }
}

function _regeneratorRuntime() {
  _regeneratorRuntime = function () {
    return e;
  };
  var t,
    e = {},
    r = Object.prototype,
    n = r.hasOwnProperty,
    o = Object.defineProperty || function (t, e, r) {
      t[e] = r.value;
    },
    i = "function" == typeof Symbol ? Symbol : {},
    a = i.iterator || "@@iterator",
    c = i.asyncIterator || "@@asyncIterator",
    u = i.toStringTag || "@@toStringTag";
  function define(t, e, r) {
    return Object.defineProperty(t, e, {
      value: r,
      enumerable: !0,
      configurable: !0,
      writable: !0
    }), t[e];
  }
  try {
    define({}, "");
  } catch (t) {
    define = function (t, e, r) {
      return t[e] = r;
    };
  }
  function wrap(t, e, r, n) {
    var i = e && e.prototype instanceof Generator ? e : Generator,
      a = Object.create(i.prototype),
      c = new Context(n || []);
    return o(a, "_invoke", {
      value: makeInvokeMethod(t, r, c)
    }), a;
  }
  function tryCatch(t, e, r) {
    try {
      return {
        type: "normal",
        arg: t.call(e, r)
      };
    } catch (t) {
      return {
        type: "throw",
        arg: t
      };
    }
  }
  e.wrap = wrap;
  var h = "suspendedStart",
    l = "suspendedYield",
    f = "executing",
    s = "completed",
    y = {};
  function Generator() {}
  function GeneratorFunction() {}
  function GeneratorFunctionPrototype() {}
  var p = {};
  define(p, a, function () {
    return this;
  });
  var d = Object.getPrototypeOf,
    v = d && d(d(values([])));
  v && v !== r && n.call(v, a) && (p = v);
  var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p);
  function defineIteratorMethods(t) {
    ["next", "throw", "return"].forEach(function (e) {
      define(t, e, function (t) {
        return this._invoke(e, t);
      });
    });
  }
  function AsyncIterator(t, e) {
    function invoke(r, o, i, a) {
      var c = tryCatch(t[r], t, o);
      if ("throw" !== c.type) {
        var u = c.arg,
          h = u.value;
        return h && "object" == typeof h && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) {
          invoke("next", t, i, a);
        }, function (t) {
          invoke("throw", t, i, a);
        }) : e.resolve(h).then(function (t) {
          u.value = t, i(u);
        }, function (t) {
          return invoke("throw", t, i, a);
        });
      }
      a(c.arg);
    }
    var r;
    o(this, "_invoke", {
      value: function (t, n) {
        function callInvokeWithMethodAndArg() {
          return new e(function (e, r) {
            invoke(t, n, e, r);
          });
        }
        return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
      }
    });
  }
  function makeInvokeMethod(e, r, n) {
    var o = h;
    return function (i, a) {
      if (o === f) throw new Error("Generator is already running");
      if (o === s) {
        if ("throw" === i) throw a;
        return {
          value: t,
          done: !0
        };
      }
      for (n.method = i, n.arg = a;;) {
        var c = n.delegate;
        if (c) {
          var u = maybeInvokeDelegate(c, n);
          if (u) {
            if (u === y) continue;
            return u;
          }
        }
        if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) {
          if (o === h) throw o = s, n.arg;
          n.dispatchException(n.arg);
        } else "return" === n.method && n.abrupt("return", n.arg);
        o = f;
        var p = tryCatch(e, r, n);
        if ("normal" === p.type) {
          if (o = n.done ? s : l, p.arg === y) continue;
          return {
            value: p.arg,
            done: n.done
          };
        }
        "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg);
      }
    };
  }
  function maybeInvokeDelegate(e, r) {
    var n = r.method,
      o = e.iterator[n];
    if (o === t) return r.delegate = null, "throw" === n && e.iterator.return && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y;
    var i = tryCatch(o, e.iterator, r.arg);
    if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y;
    var a = i.arg;
    return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y);
  }
  function pushTryEntry(t) {
    var e = {
      tryLoc: t[0]
    };
    1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e);
  }
  function resetTryEntry(t) {
    var e = t.completion || {};
    e.type = "normal", delete e.arg, t.completion = e;
  }
  function Context(t) {
    this.tryEntries = [{
      tryLoc: "root"
    }], t.forEach(pushTryEntry, this), this.reset(!0);
  }
  function values(e) {
    if (e || "" === e) {
      var r = e[a];
      if (r) return r.call(e);
      if ("function" == typeof e.next) return e;
      if (!isNaN(e.length)) {
        var o = -1,
          i = function next() {
            for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next;
            return next.value = t, next.done = !0, next;
          };
        return i.next = i;
      }
    }
    throw new TypeError(typeof e + " is not iterable");
  }
  return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", {
    value: GeneratorFunctionPrototype,
    configurable: !0
  }), o(GeneratorFunctionPrototype, "constructor", {
    value: GeneratorFunction,
    configurable: !0
  }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) {
    var e = "function" == typeof t && t.constructor;
    return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name));
  }, e.mark = function (t) {
    return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t;
  }, e.awrap = function (t) {
    return {
      __await: t
    };
  }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () {
    return this;
  }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) {
    void 0 === i && (i = Promise);
    var a = new AsyncIterator(wrap(t, r, n, o), i);
    return e.isGeneratorFunction(r) ? a : a.next().then(function (t) {
      return t.done ? t.value : a.next();
    });
  }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () {
    return this;
  }), define(g, "toString", function () {
    return "[object Generator]";
  }), e.keys = function (t) {
    var e = Object(t),
      r = [];
    for (var n in e) r.push(n);
    return r.reverse(), function next() {
      for (; r.length;) {
        var t = r.pop();
        if (t in e) return next.value = t, next.done = !1, next;
      }
      return next.done = !0, next;
    };
  }, e.values = values, Context.prototype = {
    constructor: Context,
    reset: function (e) {
      if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t);
    },
    stop: function () {
      this.done = !0;
      var t = this.tryEntries[0].completion;
      if ("throw" === t.type) throw t.arg;
      return this.rval;
    },
    dispatchException: function (e) {
      if (this.done) throw e;
      var r = this;
      function handle(n, o) {
        return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o;
      }
      for (var o = this.tryEntries.length - 1; o >= 0; --o) {
        var i = this.tryEntries[o],
          a = i.completion;
        if ("root" === i.tryLoc) return handle("end");
        if (i.tryLoc <= this.prev) {
          var c = n.call(i, "catchLoc"),
            u = n.call(i, "finallyLoc");
          if (c && u) {
            if (this.prev < i.catchLoc) return handle(i.catchLoc, !0);
            if (this.prev < i.finallyLoc) return handle(i.finallyLoc);
          } else if (c) {
            if (this.prev < i.catchLoc) return handle(i.catchLoc, !0);
          } else {
            if (!u) throw new Error("try statement without catch or finally");
            if (this.prev < i.finallyLoc) return handle(i.finallyLoc);
          }
        }
      }
    },
    abrupt: function (t, e) {
      for (var r = this.tryEntries.length - 1; r >= 0; --r) {
        var o = this.tryEntries[r];
        if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) {
          var i = o;
          break;
        }
      }
      i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null);
      var a = i ? i.completion : {};
      return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a);
    },
    complete: function (t, e) {
      if ("throw" === t.type) throw t.arg;
      return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y;
    },
    finish: function (t) {
      for (var e = this.tryEntries.length - 1; e >= 0; --e) {
        var r = this.tryEntries[e];
        if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y;
      }
    },
    catch: function (t) {
      for (var e = this.tryEntries.length - 1; e >= 0; --e) {
        var r = this.tryEntries[e];
        if (r.tryLoc === t) {
          var n = r.completion;
          if ("throw" === n.type) {
            var o = n.arg;
            resetTryEntry(r);
          }
          return o;
        }
      }
      throw new Error("illegal catch attempt");
    },
    delegateYield: function (e, r, n) {
      return this.delegate = {
        iterator: values(e),
        resultName: r,
        nextLoc: n
      }, "next" === this.method && (this.arg = t), y;
    }
  }, e;
}
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
  try {
    var info = gen[key](arg);
    var value = info.value;
  } catch (error) {
    reject(error);
    return;
  }
  if (info.done) {
    resolve(value);
  } else {
    Promise.resolve(value).then(_next, _throw);
  }
}
function _asyncToGenerator(fn) {
  return function () {
    var self = this,
      args = arguments;
    return new Promise(function (resolve, reject) {
      var gen = fn.apply(self, args);
      function _next(value) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
      }
      function _throw(err) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
      }
      _next(undefined);
    });
  };
}
function _extends() {
  _extends = Object.assign ? Object.assign.bind() : function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}
function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }
  return target;
}

var _excluded = ["tag", "className", "children", "propSelectors"],
  _excluded2 = ["selector", "propSelectors"],
  _excluded3 = ["selector", "propSelectors"];
var thisModule = "@plasmicpkgs/plasmic-basic-components";
/**
 * @deprecated This should be imported from @plasmicapp/host instead.
 */
var applySelector = function applySelector() {
  console.warn("DEPRECATED: Import applySelector from @plasmicapp/host instead.");
  return host.applySelector.apply(void 0, arguments);
};
/**
 * @deprecated This should be imported from @plasmicapp/host instead.
 */
var useSelector = function useSelector() {
  console.warn("DEPRECATED: Import useSelector from @plasmicapp/host instead.");
  return host.useSelector.apply(void 0, arguments);
};
/**
 * @deprecated This should be imported from @plasmicapp/host instead.
 */
var useSelectors = function useSelectors() {
  console.warn("DEPRECATED: Import useSelectors from @plasmicapp/host instead.");
  return host.useSelectors.apply(void 0, arguments);
};
/**
 * @deprecated This should be imported from @plasmicapp/host instead.
 */
var useDataEnv = function useDataEnv() {
  console.warn("DEPRECATED: Import useDataEnv from @plasmicapp/host instead.");
  return host.useDataEnv.apply(void 0, arguments);
};
var DataProvider = function DataProvider() {
  return host.DataProvider.apply(void 0, arguments);
};
function DynamicElement(_ref) {
  var _ref$tag = _ref.tag,
    tag = _ref$tag === void 0 ? "div" : _ref$tag,
    className = _ref.className,
    children = _ref.children,
    propSelectors = _ref.propSelectors,
    props = _objectWithoutPropertiesLoose(_ref, _excluded);
  var computed = host.useSelectors(propSelectors);
  return React.createElement(tag, _extends({
    children: children
  }, props, computed, {
    className: className + " " + computed.className
  }));
}
function DynamicText(_ref2) {
  var selector = _ref2.selector,
    propSelectors = _ref2.propSelectors,
    props = _objectWithoutPropertiesLoose(_ref2, _excluded2);
  return React__default.createElement(DynamicElement, Object.assign({}, props, {
    propSelectors: _extends({}, propSelectors, {
      children: selector
    })
  }), "(DynamicText requires a selector)");
}
function DynamicImage(_ref3) {
  var selector = _ref3.selector,
    propSelectors = _ref3.propSelectors,
    props = _objectWithoutPropertiesLoose(_ref3, _excluded3);
  return React__default.createElement(DynamicElement, Object.assign({
    tag: "img",
    loading: "lazy",
    style: {
      objectFit: "cover"
    }
  }, props, {
    propSelectors: _extends({}, propSelectors, {
      src: selector
    }),
    // Default image placeholder
    src: "https://studio.plasmic.app/static/img/placeholder.png"
  }));
}
function DynamicRepeater(_ref4) {
  var _ref5;
  var children = _ref4.children,
    loopItemName = _ref4.loopItemName,
    keySelector = _ref4.keySelector,
    selector = _ref4.selector,
    data = _ref4.data;
  // Defaults to an array of three items.
  var finalData = (_ref5 = data != null ? data : host.useSelector(selector)) != null ? _ref5 : [1, 2, 3];
  return React__default.createElement(React__default.Fragment, null, finalData == null || finalData.map == null ? void 0 : finalData.map(function (item, index) {
    var _applySelector2;
    return React__default.createElement(host.DataProvider, {
      key: (_applySelector2 = host.applySelector(item, keySelector)) != null ? _applySelector2 : index,
      name: loopItemName,
      data: item
    }, host.repeatedElement(index, children));
  }));
}
var dynamicRepeaterProps = {
  selector: {
    type: "string",
    description: "The selector expression to use to get the array of data to loop over, such as: someVariable.0.someField"
  },
  loopItemName: {
    type: "string",
    defaultValue: "item",
    description: "The name of the variable to use to store the current item in the loop"
  },
  children: {
    type: "slot",
    isRepeated: true
  }
};
var dynamicRepeaterMeta = {
  name: "hostless-dynamic-repeater",
  displayName: "Dynamic Repeater",
  importName: "DynamicRepeater",
  importPath: thisModule,
  props: dynamicRepeaterProps
};
function registerDynamicRepeater(loader, customDynamicRepeaterMeta) {
  if (loader) {
    loader.registerComponent(DynamicRepeater, customDynamicRepeaterMeta != null ? customDynamicRepeaterMeta : dynamicRepeaterMeta);
  } else {
    registerComponent(DynamicRepeater, customDynamicRepeaterMeta != null ? customDynamicRepeaterMeta : dynamicRepeaterMeta);
  }
}
var dataProviderMeta = {
  name: "hostless-data-provider",
  displayName: "Data Provider",
  importName: "DataProvider",
  importPath: thisModule,
  providesData: true,
  // description: "Makes some specified data available to the subtree in a context",
  props: {
    name: {
      type: "string",
      defaultValue: "celebrities",
      description: "The name of the variable to store the data in"
    },
    data: {
      type: "object",
      defaultValue: [{
        name: "Fill Murray",
        birthYear: 1950,
        profilePicture: ["https://www.fillmurray.com/200/300"]
      }, {
        name: "Place Cage",
        birthYear: 1950,
        profilePicture: ["https://www.placecage.com/200/300"]
      }]
    },
    children: {
      type: "slot"
    }
  }
};
function registerDataProvider(loader, customDataProviderMeta) {
  if (loader) {
    loader.registerComponent(host.DataProvider, customDataProviderMeta != null ? customDataProviderMeta : dataProviderMeta);
  } else {
    registerComponent(host.DataProvider, customDataProviderMeta != null ? customDataProviderMeta : dataProviderMeta);
  }
}
var dynamicPropsWithoutTag = {
  propSelectors: {
    type: "object",
    defaultValueHint: {},
    description: "An object whose keys are prop names and values are selector expressions. Use this to set any prop to a dynamic value."
  }
};
var dynamicProps = /*#__PURE__*/_extends({}, dynamicPropsWithoutTag, {
  tag: {
    type: "string",
    defaultValueHint: "div",
    description: "The HTML tag to use"
  }
});
// TODO Eventually we'll want to expose all the base HTML properties, but in the nicer way that we do within the studio.
var dynamicElementMeta = {
  name: "hostless-dynamic-element",
  displayName: "Dynamic Element",
  importName: "DynamicElement",
  importPath: thisModule,
  props: /*#__PURE__*/_extends({}, dynamicProps, {
    children: "slot"
  })
};
function registerDynamicElement(loader, customDynamicElementMeta) {
  if (loader) {
    loader.registerComponent(DynamicElement, customDynamicElementMeta != null ? customDynamicElementMeta : dynamicElementMeta);
  } else {
    registerComponent(DynamicElement, customDynamicElementMeta != null ? customDynamicElementMeta : dynamicElementMeta);
  }
}
var dynamicTextMeta = {
  name: "hostless-dynamic-text",
  importName: "DynamicText",
  displayName: "Dynamic Text",
  importPath: thisModule,
  props: /*#__PURE__*/_extends({}, dynamicProps, {
    selector: {
      type: "string",
      description: "The selector expression to use to get the text, such as: someVariable.0.someField"
    }
  })
};
function registerDynamicText(loader, customDynamicTextMeta) {
  if (loader) {
    loader.registerComponent(DynamicText, customDynamicTextMeta != null ? customDynamicTextMeta : dynamicTextMeta);
  } else {
    registerComponent(DynamicText, customDynamicTextMeta != null ? customDynamicTextMeta : dynamicTextMeta);
  }
}
var dynamicImageMeta = {
  name: "hostless-dynamic-image",
  displayName: "Dynamic Image",
  importName: "DynamicImage",
  importPath: thisModule,
  props: /*#__PURE__*/_extends({}, dynamicPropsWithoutTag, {
    selector: {
      type: "string",
      description: "The selector expression to use to get the image source URL, such as: someVariable.0.someField"
    }
  })
};
function registerDynamicImage(loader, customDynamicImageMeta) {
  if (loader) {
    loader.registerComponent(DynamicImage, customDynamicImageMeta != null ? customDynamicImageMeta : dynamicImageMeta);
  } else {
    registerComponent(DynamicImage, customDynamicImageMeta != null ? customDynamicImageMeta : dynamicImageMeta);
  }
}

function ensure(x) {
  if (x === null || x === undefined) {
    debugger;
    throw new Error("Value must not be undefined or null");
  } else {
    return x;
  }
}
var isBrowser = typeof window !== "undefined";
var useIsomorphicLayoutEffect = isBrowser ? React__default.useLayoutEffect : React__default.useEffect;
function useFirstRender() {
  var ref = React__default.useRef(true);
  var firstRender = ref.current;
  ref.current = false;
  return firstRender;
}
// Fix for React.useId type since it's only available for React 18+
var useId = React__default.useId;

/**
 * A common use case for embedding HTML snippets is loading/running script tags, so most of the logic here is for
 * handling that.
 *
 * You can't just write innerHTML with some <script> tags in there. You need to explicitly add each one via the DOM API.
 *
 * You also can't just add the script tags and expect them to run sequentially, and sometimes there are multiple scripts
 * with dependencies on each other. You have to explicitly wait for earlier ones to finish loading.
 *
 * One last complication is that Next.js can run the effect multiple times in development mode. There's nothing actually
 * that we can/should do about that, but just something to be aware of if you are here debugging issues.
 */
function Embed(_ref) {
  var className = _ref.className,
    code = _ref.code,
    _ref$hideInEditor = _ref.hideInEditor,
    hideInEditor = _ref$hideInEditor === void 0 ? false : _ref$hideInEditor;
  var rootElt = React.useRef(null);
  var inEditor = host.usePlasmicCanvasContext();
  var htmlId = useId == null ? void 0 : useId();
  var firstRender = useFirstRender();
  React.useEffect(function () {
    if (hideInEditor && inEditor) {
      return;
    }
    // If it's the first render and we already set the global id for this component, it means that
    // the HTML is already present in the DOM from the server-rendered HTML. We don't want to re-run.
    // If it's not the first render, then it can mean that some dependency changed.
    if (htmlId && !inEditor && firstRender && window[makePlasmicVarName(htmlId)]) {
      return;
    }
    // Load scripts sequentially one at a time, since later scripts can depend on earlier ones.
    _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
      var _loop, _i, _Array$from;
      return _regeneratorRuntime().wrap(function _callee$(_context2) {
        while (1) switch (_context2.prev = _context2.next) {
          case 0:
            _loop = /*#__PURE__*/_regeneratorRuntime().mark(function _loop() {
              var oldScript, newScript;
              return _regeneratorRuntime().wrap(function _loop$(_context) {
                while (1) switch (_context.prev = _context.next) {
                  case 0:
                    oldScript = _Array$from[_i];
                    newScript = document.createElement("script"); // This doesn't actually have the effect we want, we need to explicitly wait on the load event, since all
                    // dynamically injected scripts are always async.
                    newScript.async = false;
                    Array.from(oldScript.attributes).forEach(function (attr) {
                      return newScript.setAttribute(attr.name, attr.value);
                    });
                    newScript.appendChild(document.createTextNode(oldScript.innerHTML));
                    ensure(oldScript.parentNode).replaceChild(newScript, oldScript);
                    // Only scripts with src will ever fire a load event.
                    if (!newScript.src) {
                      _context.next = 9;
                      break;
                    }
                    _context.next = 9;
                    return new Promise(function (resolve) {
                      return newScript.addEventListener("load", resolve);
                    });
                  case 9:
                  case "end":
                    return _context.stop();
                }
              }, _loop);
            });
            _i = 0, _Array$from = Array.from(ensure(rootElt.current).querySelectorAll("script"));
          case 2:
            if (!(_i < _Array$from.length)) {
              _context2.next = 7;
              break;
            }
            return _context2.delegateYield(_loop(), "t0", 4);
          case 4:
            _i++;
            _context2.next = 2;
            break;
          case 7:
          case "end":
            return _context2.stop();
        }
      }, _callee);
    }))();
  }, [htmlId, firstRender, code, hideInEditor, inEditor]);
  var effectiveCode = hideInEditor && inEditor ? "" : inEditor || !htmlId ? code : addIdentifierScript(htmlId, code);
  return React__default.createElement("div", {
    ref: rootElt,
    className: className,
    dangerouslySetInnerHTML: {
      __html: effectiveCode
    },
    style: {
      whiteSpace: "normal"
    }
  });
}
function makePlasmicVarName(id) {
  return "__plasmic_" + id.replace(/[^a-z0-9]/gi, "");
}
function addIdentifierScript(id, code) {
  return "<script>\n    var " + makePlasmicVarName(id) + " = 1;\n  </script>\n  " + code;
}
var embedMeta = {
  name: "hostless-embed",
  displayName: "Embed HTML",
  importName: "Embed",
  importPath: "@plasmicpkgs/plasmic-basic-components",
  props: {
    code: {
      type: "code",
      lang: "html",
      defaultValue: "<div>Paste your embed code via the right sidebar</div>",
      description: "The HTML code to be embedded"
    },
    hideInEditor: {
      type: "boolean",
      displayName: "Hide in editor",
      description: "Disable running the code while editing in Plasmic Studio (may require reload)",
      editOnly: true
    }
  },
  defaultStyles: {
    maxWidth: "100%"
  }
};
function registerEmbed(loader, customEmbedMeta) {
  if (loader) {
    loader.registerComponent(Embed, customEmbedMeta != null ? customEmbedMeta : embedMeta);
  } else {
    registerComponent(Embed, customEmbedMeta != null ? customEmbedMeta : embedMeta);
  }
}

function Iframe(_ref) {
  var preview = _ref.preview,
    src = _ref.src,
    className = _ref.className,
    onLoad = _ref.onLoad;
  var isEditing = React.useContext(host.PlasmicCanvasContext);
  if (isEditing && !preview) {
    return React__default.createElement("div", {
      className: className
    }, React__default.createElement("div", {
      style: {
        position: "absolute",
        top: 0,
        left: 0,
        right: 0,
        bottom: 0,
        background: "#eee",
        color: "#888",
        fontSize: "36px",
        fontFamily: "sans-serif",
        fontWeight: "bold",
        display: "flex",
        alignItems: "center",
        justifyContent: "center",
        overflow: "hidden"
      }
    }, "Iframe placeholder"));
  }
  return React__default.createElement("iframe", {
    src: src,
    className: className,
    onLoad: onLoad
  });
}
var iframeMeta = {
  name: "hostless-iframe",
  displayName: "Iframe",
  importName: "Iframe",
  importPath: "@plasmicpkgs/plasmic-basic-components",
  props: {
    src: {
      type: "string",
      defaultValue: "https://www.example.com"
    },
    preview: {
      type: "boolean",
      description: "Load the iframe while editing in Plasmic Studio"
    },
    onLoad: {
      type: "eventHandler",
      argTypes: [{
        name: "event",
        type: "object"
      }]
    }
  },
  defaultStyles: {
    width: "300px",
    height: "150px",
    maxWidth: "100%"
  }
};
function registerIframe(loader, customIframeMeta) {
  if (loader) {
    loader.registerComponent(Iframe, customIframeMeta != null ? customIframeMeta : iframeMeta);
  } else {
    registerComponent(Iframe, customIframeMeta != null ? customIframeMeta : iframeMeta);
  }
}

var reactMajorVersion = + /*#__PURE__*/React__default.version.split(".")[0];
if (reactMajorVersion < 18) {
  console.warn("The LoadingBoundary component only works with React 18+");
}
var enableLoadingBoundaryKey = "plasmicInternalEnableLoadingBoundary";
var hasLoadingBoundaryKey = "plasmicInternalHasLoadingBoundary";
function useIsClient() {
  var _useState = React.useState(false),
    loaded = _useState[0],
    setLoaded = _useState[1];
  useIsomorphicLayoutEffect(function () {
    setLoaded(true);
  }, []);
  return loaded;
}
var hasWarnedDisabledLoadingBoundary = false;
function warnDisabledLoadingBoundary() {
  if (!hasWarnedDisabledLoadingBoundary) {
    hasWarnedDisabledLoadingBoundary = true;
    console.warn("LoadingBoundary feature is not enabled. To use the LoadingBoundary component make sure to upgrade your @plasmicapp/* dependencies to the latest version and to wrap you App inside <PlasmicRootProvider />");
  }
}
function LoadingBoundary(_ref) {
  var _useDataEnv;
  var children = _ref.children,
    forceLoading = _ref.forceLoading,
    loadingState = _ref.loadingState;
  var isClient = useIsClient();
  var enableLoadingBoundary = !!((_useDataEnv = host.useDataEnv()) != null && _useDataEnv[enableLoadingBoundaryKey]);
  if (!isClient && !(plasmicQuery.isPlasmicPrepass != null && plasmicQuery.isPlasmicPrepass())) {
    return null;
  }
  if (forceLoading) {
    return React__default.createElement(React__default.Fragment, null, loadingState != null ? loadingState : null);
  }
  if (reactMajorVersion < 18) {
    return React__default.createElement(React__default.Fragment, null, children != null ? children : null);
  }
  if (!enableLoadingBoundary) {
    warnDisabledLoadingBoundary();
    return React__default.createElement(React__default.Fragment, null, children != null ? children : null);
  }
  return React__default.createElement(React.Suspense, {
    fallback: React__default.createElement(React__default.Fragment, null, loadingState != null ? loadingState : null)
  }, React__default.createElement(host.DataProvider, {
    hidden: true,
    name: hasLoadingBoundaryKey,
    data: true
  }, children != null ? children : null));
}
var loadingBoundaryMeta = {
  name: "hostless-loading-boundary",
  displayName: "Loading Boundary",
  importName: "LoadingBoundary",
  importPath: "@plasmicpkgs/plasmic-basic-components",
  props: {
    children: "slot",
    loadingState: {
      type: "slot",
      displayName: "Loading state",
      defaultValue: {
        type: "text",
        value: "Loading..."
      }
    },
    forceLoading: {
      type: "boolean",
      editOnly: true,
      displayName: "Preview loading",
      description: "Force preview the 'Loading' state - impacts only editor, and not published page behavior"
    }
  },
  providesData: true,
  styleSections: false,
  description: "Handle the loading state of queries and integrations"
};
function registerLoadingBoundary(loader, customLoadingBoundaryMeta) {
  if (loader) {
    loader.registerComponent(LoadingBoundary, customLoadingBoundaryMeta != null ? customLoadingBoundaryMeta : loadingBoundaryMeta);
  } else {
    registerComponent(LoadingBoundary, customLoadingBoundaryMeta != null ? customLoadingBoundaryMeta : loadingBoundaryMeta);
  }
}

var thisModule$1 = "@plasmicpkgs/plasmic-basic-components";
var defaultItemName = "currentItem";
var defaultIndexName = "currentIndex";
function Repeater(props) {
  var children = props.children,
    items = props.items,
    itemName = props.itemName,
    indexName = props.indexName;
  if (!Array.isArray(items)) {
    throw new Error("Repeater received an invalid collection: not an array.");
  }
  return React__default.createElement(React__default.Fragment, null, items.map(function (item, index) {
    return React__default.createElement(host.DataProvider, {
      key: index.toString(),
      name: itemName || defaultItemName,
      data: item
    }, React__default.createElement(host.DataProvider, {
      name: indexName || defaultIndexName,
      data: index
    }, host.repeatedElement(index, children)));
  }));
}
var repeaterMeta = {
  name: "plasmic-repeater",
  displayName: "Repeater",
  importName: "Repeater",
  importPath: thisModule$1,
  providesData: true,
  props: {
    children: {
      type: "slot",
      isRepeated: true
    },
    items: {
      type: "array",
      defaultValue: [1, 2, 3],
      displayName: "Collection",
      description: "Items array (JavaScript expression)."
    },
    itemName: {
      type: "string",
      defaultValue: defaultItemName,
      defaultValueHint: defaultItemName,
      displayName: "Item",
      description: "Data context key for the current item."
    },
    indexName: {
      type: "string",
      defaultValue: defaultIndexName,
      defaultValueHint: defaultIndexName,
      displayName: "Index",
      description: "Data context key for the index of the current item."
    }
  }
};
function registerRepeater(loader, customRepeaterMeta) {
  if (loader) {
    loader.registerComponent(Repeater, customRepeaterMeta != null ? customRepeaterMeta : repeaterMeta);
  } else {
    host.registerComponent(Repeater, customRepeaterMeta != null ? customRepeaterMeta : repeaterMeta);
  }
}

function useDirectionalIntersection(_ref) {
  var ref = _ref.ref,
    _ref$scrollDownThresh = _ref.scrollDownThreshold,
    scrollDownThreshold = _ref$scrollDownThresh === void 0 ? 0.5 : _ref$scrollDownThresh,
    _ref$scrollUpThreshol = _ref.scrollUpThreshold,
    scrollUpThreshold = _ref$scrollUpThreshol === void 0 ? 0 : _ref$scrollUpThreshol;
  var _useState = React.useState(false),
    revealed = _useState[0],
    setRevealed = _useState[1];
  React.useEffect(function () {
    if (ref.current && typeof IntersectionObserver === "function") {
      var handler = function handler(entries) {
        if (entries[0].intersectionRatio >= scrollDownThreshold) {
          setRevealed(true);
        } else if (entries[0].intersectionRatio <= scrollUpThreshold) {
          setRevealed(false);
        }
      };
      var observer = new IntersectionObserver(handler, {
        root: null,
        rootMargin: "0%",
        threshold: [scrollUpThreshold, scrollDownThreshold]
      });
      observer.observe(ref.current);
      return function () {
        setRevealed(false);
        observer.disconnect();
      };
    }
    return function () {};
  }, [ref.current, scrollDownThreshold, scrollUpThreshold]);
  return revealed;
}
/**
 * Unlike react-awesome-reveal, ScrollRevealer:
 *
 * - has configurable thresholds
 * - triggers arbitrary render/unrender animations
 *
 * TODO: Merge this inta a general Reveal component, perhaps forking react-awesome-reveal, so that we don't have two different reveal components for users.
 */
function ScrollRevealer(_ref2) {
  var children = _ref2.children,
    className = _ref2.className,
    _ref2$scrollDownThres = _ref2.scrollDownThreshold,
    scrollDownThreshold = _ref2$scrollDownThres === void 0 ? 0.5 : _ref2$scrollDownThres,
    _ref2$scrollUpThresho = _ref2.scrollUpThreshold,
    scrollUpThreshold = _ref2$scrollUpThresho === void 0 ? 0 : _ref2$scrollUpThresho;
  var intersectionRef = React.useRef(null);
  var revealed = useDirectionalIntersection({
    ref: intersectionRef,
    scrollUpThreshold: scrollUpThreshold,
    scrollDownThreshold: scrollDownThreshold
  });
  return React__default.createElement("div", {
    className: className,
    ref: intersectionRef
  }, revealed ? children : null);
}
var scrollRevealerMeta = {
  name: "hostless-scroll-revealer",
  importName: "ScrollRevealer",
  displayName: "Scroll Revealer",
  importPath: "@plasmicpkgs/plasmic-basic-components",
  props: {
    children: "slot",
    scrollDownThreshold: {
      type: "number",
      displayName: "Scroll down threshold",
      defaultValueHint: 0.5,
      description: "How much of the element (as a fraction) must you scroll into view for it to appear (defaults to 0.5)"
    },
    scrollUpThreshold: {
      type: "number",
      displayName: "Scroll up threshold",
      defaultValueHint: 0,
      description: "While scrolling up, how much of the element (as a fraction) can still be scrolled in view before it disappears (defaults to 0, meaning you must scroll up until it's completely out of view)"
    }
  },
  defaultStyles: {
    width: "stretch",
    maxWidth: "100%"
  }
};
function registerScrollRevealer(loader, customScrollRevealerMeta) {
  if (loader) {
    loader.registerComponent(ScrollRevealer, customScrollRevealerMeta != null ? customScrollRevealerMeta : scrollRevealerMeta);
  } else {
    registerComponent(ScrollRevealer, customScrollRevealerMeta != null ? customScrollRevealerMeta : scrollRevealerMeta);
  }
}

function SideEffect(_ref) {
  var deps = _ref.deps,
    onMount = _ref.onMount,
    onUnmount = _ref.onUnmount;
  React__default.useEffect(function () {
    onMount == null || onMount();
    return function () {
      onUnmount == null || onUnmount();
    };
  }, deps != null ? deps : []);
  return null;
}
var sideEffectMeta = {
  name: "hostless-side-effect",
  displayName: "Side Effect",
  description: "Run actions on load, unload, and when data changes.",
  importName: "SideEffect",
  importPath: "@plasmicpkgs/plasmic-basic-components",
  props: {
    onMount: {
      type: "eventHandler",
      displayName: "On load",
      description: "Actions to run when this Side Effect component is mounted.",
      argTypes: []
    },
    onUnmount: {
      type: "eventHandler",
      displayName: "On unload",
      description: "Actions to run when this Side Effect component is unmounted.",
      argTypes: []
    },
    deps: {
      type: "array",
      displayName: "When data changes",
      description: "List of values which should trigger a re-run of the actions if changed."
    }
  }
};
function registerSideEffect(loader, customMeta) {
  if (loader) {
    loader.registerComponent(SideEffect, customMeta != null ? customMeta : sideEffectMeta);
  } else {
    registerComponent(SideEffect, customMeta != null ? customMeta : sideEffectMeta);
  }
}

function useInterval(callback, delay) {
  var savedCallback = React.useRef(callback);
  // Remember the latest callback if it changes.
  useIsomorphicLayoutEffect(function () {
    savedCallback.current = callback;
  }, [callback]);
  // Set up the interval.
  React.useEffect(function () {
    // Don't schedule if no delay is specified.
    // Note: 0 is a valid value for delay.
    if (!delay && delay !== 0) {
      return;
    }
    var id = setInterval(function () {
      return savedCallback.current();
    }, delay);
    return function () {
      return clearInterval(id);
    };
  }, [delay]);
}
function Timer(_ref) {
  var _ref$intervalSeconds = _ref.intervalSeconds,
    intervalSeconds = _ref$intervalSeconds === void 0 ? 1 : _ref$intervalSeconds,
    _ref$isRunning = _ref.isRunning,
    isRunning = _ref$isRunning === void 0 ? false : _ref$isRunning,
    _ref$onTick = _ref.onTick,
    onTick = _ref$onTick === void 0 ? function () {} : _ref$onTick,
    runWhileEditing = _ref.runWhileEditing,
    canvasId = _ref["data-plasmic-canvas-envs"];
  var isEditMode = React.useMemo(function () {
    return canvasId !== undefined;
  }, [canvasId]);
  useInterval(onTick,
  // Delay in milliseconds or null to stop it
  isRunning && (isEditMode ? runWhileEditing : true) ? intervalSeconds * 1000 : null);
  return null;
}
var timerMeta = {
  name: "hostless-timer",
  displayName: "Timer",
  description: "Run something periodically",
  importName: "Timer",
  importPath: "@plasmicpkgs/plasmic-basic-components",
  props: {
    onTick: {
      type: "eventHandler",
      displayName: "Run this every interval",
      description: "Actions to run periodically",
      argTypes: []
    },
    isRunning: {
      type: "boolean",
      displayName: "Is Running?",
      defaultValue: true
    },
    runWhileEditing: {
      type: "boolean",
      displayName: "Run while editing",
      description: "Normally this only runs in the live site or in preview mode, but you can force it to run even while you are editing in the canvas (Please enable interactive mode to observe state changes)",
      defaultValue: false
    },
    intervalSeconds: {
      type: "number",
      displayName: "Interval (seconds)",
      description: "Interval in seconds"
    }
  }
};
function registerTimer(loader, customMeta) {
  if (loader) {
    loader.registerComponent(Timer, customMeta != null ? customMeta : timerMeta);
  } else {
    registerComponent(Timer, customMeta != null ? customMeta : timerMeta);
  }
}

var Video = /*#__PURE__*/React__default.forwardRef(function (props, ref) {
  return React__default.createElement("video", Object.assign({
    ref: ref
  }, props));
});
var videoMeta = {
  name: "hostless-html-video",
  importName: "Video",
  displayName: "HTML Video",
  importPath: "@plasmicpkgs/plasmic-basic-components",
  props: {
    src: {
      type: "string",
      defaultValue: "https://interactive-examples.mdn.mozilla.net/media/cc0-videos/flower.webm",
      displayName: "Source URL",
      description: "URL to a video file."
    },
    autoPlay: {
      type: "boolean",
      displayName: "Auto Play",
      description: "Whether the video show automatically start playing when the player loads. Chrome and other browsers require 'muted' to also be set for 'autoplay' to work.",
      helpText: "Requires 'Muted' to also be set for 'Auto Play' to work."
    },
    controls: {
      type: "boolean",
      displayName: "Show Controls",
      description: "Whether the video player controls should be displayed",
      defaultValue: true
    },
    playsInline: {
      type: "boolean",
      displayName: "Plays inline",
      description: "Usually on mobile, when tilted landscape, videos can play fullscreen. Turn this on to prevent that."
    },
    loop: {
      type: "boolean",
      displayName: "Loop",
      description: "Whether the video should be played again after it finishes"
    },
    muted: {
      type: "boolean",
      displayName: "Muted",
      description: "Whether audio should be muted"
    },
    poster: {
      type: "imageUrl",
      displayName: "Poster (placeholder) image",
      description: "Image to show while video is downloading"
    },
    preload: {
      type: "choice",
      options: ["none", "metadata", "auto"],
      displayName: "Preload",
      description: "Whether to preload nothing, metadata only, or the full video"
    }
  },
  defaultStyles: {
    height: "hug",
    width: "640px",
    maxWidth: "100%"
  }
};
function registerVideo(loader, customVideoMeta) {
  if (loader) {
    loader.registerComponent(Video, customVideoMeta != null ? customVideoMeta : videoMeta);
  } else {
    registerComponent(Video, customVideoMeta != null ? customVideoMeta : videoMeta);
  }
}

exports.ConditionGuard = ConditionGuard;
exports.DataProvider = DataProvider;
exports.DynamicElement = DynamicElement;
exports.DynamicImage = DynamicImage;
exports.DynamicRepeater = DynamicRepeater;
exports.DynamicText = DynamicText;
exports.Embed = Embed;
exports.Iframe = Iframe;
exports.LoadingBoundary = LoadingBoundary;
exports.Repeater = Repeater;
exports.ScrollRevealer = ScrollRevealer;
exports.SideEffect = SideEffect;
exports.Timer = Timer;
exports.Video = Video;
exports.applySelector = applySelector;
exports.conditionGuardMeta = conditionGuardMeta;
exports.dataProviderMeta = dataProviderMeta;
exports.dynamicElementMeta = dynamicElementMeta;
exports.dynamicImageMeta = dynamicImageMeta;
exports.dynamicRepeaterMeta = dynamicRepeaterMeta;
exports.dynamicRepeaterProps = dynamicRepeaterProps;
exports.dynamicTextMeta = dynamicTextMeta;
exports.embedMeta = embedMeta;
exports.iframeMeta = iframeMeta;
exports.loadingBoundaryMeta = loadingBoundaryMeta;
exports.registerConditionGuard = registerConditionGuard;
exports.registerDataProvider = registerDataProvider;
exports.registerDynamicElement = registerDynamicElement;
exports.registerDynamicImage = registerDynamicImage;
exports.registerDynamicRepeater = registerDynamicRepeater;
exports.registerDynamicText = registerDynamicText;
exports.registerEmbed = registerEmbed;
exports.registerIframe = registerIframe;
exports.registerLoadingBoundary = registerLoadingBoundary;
exports.registerRepeater = registerRepeater;
exports.registerScrollRevealer = registerScrollRevealer;
exports.registerSideEffect = registerSideEffect;
exports.registerTimer = registerTimer;
exports.registerVideo = registerVideo;
exports.repeaterMeta = repeaterMeta;
exports.scrollRevealerMeta = scrollRevealerMeta;
exports.sideEffectMeta = sideEffectMeta;
exports.timerMeta = timerMeta;
exports.useDataEnv = useDataEnv;
exports.useDirectionalIntersection = useDirectionalIntersection;
exports.useInterval = useInterval;
exports.useSelector = useSelector;
exports.useSelectors = useSelectors;
exports.videoMeta = videoMeta;
//# sourceMappingURL=plasmic-basic-components.cjs.development.js.map
