#data validation to ensure that data we store, follows a proper format
from pydantic import BaseModel , EmailStr, constr  #pydantiic is a data validation and serialization library that FastAPII uses to ensure data is valid and structured properly
from typing import Optional,List,Dict, Literal
from datetime import datetime
from typing import Any, Dict

#define Pydantic models
class SignupResponse(BaseModel):
    success: bool
    message: str
        

class FriendsBase(BaseModel):   #defines the fields that should exist in every contact objects
    name:str
    phone_number:Optional[str]=None   #not sure to add these
    emaiL:Optional[str] =None
    
    
    
class FriendsResponse(FriendsBase):
    class config:
        orm_mode=True
        

class UserCreate(BaseModel):
    username: str
    email: str
    password: str  # Raw password (to be hashed before saving)
    gender: str
    
class ProfileCreate(BaseModel):
    username: str
    password: str
    email: str
    personality: str
    mbti: str

class UserFriend(BaseModel):
    username: str
    password: str
    email: str
    contacts: List
    initial_note: Optional[str] = None


# Schema for returning user data (output)
class UserResponse(BaseModel):
    user_id: int  # Automatically generated by DB
    username: str
    email: str
    gender: str
    personality_type: Optional[str] = None
    mbti: Optional[str] = None
    profile_photo: Optional[str]=None
    created_at: Optional[datetime] = None
    updated_at:Optional[datetime]=None
    contacts: Optional[List[Dict[str, Any]]] = None

    class Config:
        from_attributes = True

class UserFriendSchema(BaseModel):
    id: int
    user_id: int
    username : str
    friend_name: str
    interaction_type: str
    timestamp: datetime
    messages: Dict[str, Any]
    score: List[Dict[str, Any]]



    class Config:
        from_attributes = True


class UserSuggestionSchema(BaseModel):
    id: int
    user_id: int
    username : str
    friend_name: str
    suggestion: str
    gender: str
    comment: str
    time_stamp: datetime
    total_score: float

    class Config:
        from_attributes = True
        

class UserLoginRequest(BaseModel):
    username:str
    password:str
    
class UserLoginResponse(BaseModel):
    message: str

    
#GenderType = constr(regex="^(Male|Female)$")
    
class UserFriendCreate(BaseModel):
    friend_name:Optional[str]=None
    token :str
    friend_telegram_username:Optional[str]=None
    gender: Optional[Literal["Male", "Female"]] = None  
    interaction_type: Optional[str] = None
    initial_note: Optional[str] = None
    messages: Optional[List[Dict[str, str]]] = None
    score: Optional[dict] = None
    profile_photo: Optional[str] = None
    initial_note: Optional[str] = None
    
class UserFriendResponse(BaseModel):
    id: int
    user_id: int
    friend_name: Optional[str] = None
    friend_telegram_username: Optional[str] = None
    gender: Optional[Literal["Male", "Female"]] = None  
    interaction_type: Optional[str] = None
    initial_note: Optional[str] = None
    messages: Optional[List[Dict[str, str]]] = None
    score: Optional[dict] = None
    profile_photo: Optional[str] = None
    timestamp: datetime

    class Config:
        from_attributes = True


class UserFriendDCreate(BaseModel):
    friend_name:Optional[str]=None
    token :str

class UserFriendDResponse(BaseModel):
    class Config:
        from_attributes = True



class UserEditRequest(BaseModel):
    token :str
    username: Optional[str]=None
    email: Optional[EmailStr]=None
    password: Optional[str]=None
    personality_type: Optional[str]=None
    mbti: Optional[str]=None
    profile_photo:Optional[str]=None 
    
    class Config:
        orm_mode =True  #allow conversion from ORM models
        
        
class UserStatistics(BaseModel):
    token :str

    
    class Config:
        orm_mode =True  #allow conversion from ORM models


class SuggestFriend(BaseModel):
    token :str
    mood:str
    
    class Config:
        orm_mode =True  #allow conversion from ORM models
